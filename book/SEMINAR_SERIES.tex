% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Predictive Modeling},
  pdfauthor={Steve Pittard},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage{booktabs}
\usepackage[]{natbib}
\bibliographystyle{apalike}

\title{Predictive Modeling}
\author{Steve Pittard}
\date{2020-12-17}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{intro}{%
\chapter{Introduction}\label{intro}}

Predictive Modeling is a type of Machine Learning which itself is a sub branch of Artificial Intelligence. The \href{https://blogs.nvidia.com/blog/2016/07/29/whats-difference-artificial-intelligence-machine-learning-deep-learning-ai/}{following graphic} provides us with some history of these domains. This is helpful if you are trying to orient yourself in the world of analytics and machine learning. Note that AI has been around for quite some time. The Wikipedia definition of AI is:

\begin{quote}
The study of ``intelligent agents'': any device that perceives its environment and takes
actions that maximize its chance of successfully achieving its goals
\end{quote}

\includegraphics{./PICS/histofai.png}

\hypertarget{machine-learning}{%
\section{Machine Learning}\label{machine-learning}}

Machine Learning relies upon ``patterns and inference''" to ``perform a specific task without using explicit instructions''. It is a form of Applied AI that attempts to automatically learn from experience without being explicitly programmed. Think of Predictive Modeling as a subset of this which falls into two categories:

\textbf{Supervised}

Algorithms that build a model on a set of data containing both the inputs and the desired outputs (``labels'' or known numeric values). When you want to map input to known output labels. Build a model that, when applied to ``new'' data, will hopefully predict the correct label.

\includegraphics{./PICS/super_class_regress.png}

Some common techniques for Supervised learning include: Generalized Linear Models (GLM),
Logistic Regression, Random Forests, Decision Trees, Neural Networks, Multivariate Adaptive Regression Splines (MARS), and K Nearest Neighbors.

\textbf{Unsupervised}

Algorithms that take a set of data that contains only inputs, and find structure in the data (e.g.~clustering of data points)

\includegraphics[width=5.20833in,height=\textheight]{./PICS/unsupervised_class.png}

Some common techniques for unsupervised learning include: hierarchical clustering, k-means
clustering, mixture models, DBSCAN, Association Rules, Neural Networks

\hypertarget{predictive-modeling}{%
\section{Predictive Modeling}\label{predictive-modeling}}

This lecture is concerned primarily with Predictive Modeling and Supervised approaches in particular. Some examples of Predictive Modeling include:

\begin{itemize}
\item
  Predict current CD4 cell count of an HIV-positive patient using genome sequences
\item
  Predict Success of Grant Applications
\item
  Use attributes of chemical compounds to predict likelihood of hepatic injury
\item
  How many copies of a new book will sell ?
\item
  Will a customer change Internet Service Providers ?
\end{itemize}

In this domain there are generally two types of predictive models.

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\tightlist
\item
  Classification for Predicting Qualitative Outcomes:
\end{enumerate}

This relates to situations such as whether someone has a disease (``positive'') or not (``negative''). The problem could also be multi classification such as assigning an organism to one of a number of possible species.

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\setcounter{enumi}{1}
\tightlist
\item
  Regression for Quantitative Out Comes
\end{enumerate}

This is when we wish to predict a numeric / continuous outcome such as a final sales price for a house or car. It might also be a prediction of tomorrow's stock or Bit Coin price.

\hypertarget{in-sample-vs-out-of-sample-error}{%
\section{In-Sample vs Out-Of-Sample Error}\label{in-sample-vs-out-of-sample-error}}

The goal of predictive model is to generate models that can generalize to new data. It would be good if any model we generate could provide a good estimate of out of sample error. It's easy to generate a model on an entire data set (in sample data) and then turn around and use that data for prediction. But how will it perform on new data ? Haven't we just over trained our model ?

\hypertarget{performance-metrics}{%
\section{Performance Metrics}\label{performance-metrics}}

For either case (regression vs classification) we need some type of metric or measure to let us know how well a given model will work on new or unseen data - also known as ``out of sample'' data. for Classification problems we look at things like ``sensitivity'', ``specificity'', ``accuracy'', and ``Area Under Curve''. For Quantitative outcomes, we look at things like Root Mean Square Error (RMSE) or Mean Absolute Error (MAE). The selection of metric will frequently depend on your domain of interest. We'll use a couple of different methods.

\hypertarget{black-box}{%
\section{Black Box}\label{black-box}}

The good news is that you can treat building predictive models as a ``Black Box''.
The bad news is that you can treat building predictive models as a ``Black Box''.

\includegraphics{./PICS/black_box.png}

\hypertarget{getting-hands-on}{%
\chapter{Getting Hands On}\label{getting-hands-on}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(tidyverse)}
\KeywordTok{library}\NormalTok{(mlbench)}
\KeywordTok{library}\NormalTok{(ROCR)}
\KeywordTok{library}\NormalTok{(DataExplorer)}
\KeywordTok{library}\NormalTok{(caret)}
\end{Highlighting}
\end{Shaded}

Here is a high level over view of an ML work flow. Note that:

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\tightlist
\item
  It is a cycle, quite likely to be repeated multiple times before arriving at some actionable result
\item
  The driving questions / hypotheses are subject to change, redefinition, or abandonment
\item
  Multiple people might be involved
\end{enumerate}

\includegraphics{./PICS/flowwork1.png}

To get the ball rolling with a practical case, let's consider the Pima Indians Data Frame. Read in a copy.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{url <-}\StringTok{ "https://raw.githubusercontent.com/steviep42/bios534_spring_2020/master/data/pima.csv"}
\NormalTok{pm <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(url)}

\KeywordTok{head}\NormalTok{(pm)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   pregnant glucose pressure triceps insulin mass pedigree age diabetes
## 1        6     148       72      35       0 33.6    0.627  50      pos
## 2        1      85       66      29       0 26.6    0.351  31      neg
## 3        8     183       64       0       0 23.3    0.672  32      pos
## 4        1      89       66      23      94 28.1    0.167  21      neg
## 5        0     137       40      35     168 43.1    2.288  33      pos
## 6        5     116       74       0       0 25.6    0.201  30      neg
\end{verbatim}

The description of the data set is as follows:

\includegraphics[width=4.94792in,height=\textheight]{./PICS/pima_desc.png}

So we now have some data on which we can build a model. Our defining question or driving motivation might be how to predict whether someone will be postitive for diabetes based on other variables within the data. Is glucose, for example, an important variable to consider ?

In lookin at the data, there is a variable in the data called ``diabetes'' which indicates the disease / diabetes status (``pos'' or ``neg'') of the person. It would be good to come up with a model that we could use with incoming data to determine if someone has diabetes.

\hypertarget{important-terminology}{%
\section{Important Terminology}\label{important-terminology}}

In predictive modeling there are some common terms to consider:

\includegraphics[width=4.94792in,height=\textheight]{./PICS/features2.png}

\hypertarget{exploratory-plots}{%
\section{Exploratory Plots}\label{exploratory-plots}}

We'll look use some stock plots from the \href{https://github.com/elastacloud/automatic-data-explorer}{\textbf{DataExplorer}} package to get a feel for the data. Look at correlations between the variables to see if any are strongly correlated with the variable we wish to predict or any other variables.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{plot_correlation}\NormalTok{(pm, }\DataTypeTok{type=}\StringTok{"continuous"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{SEMINAR_SERIES_files/figure-latex/decorr-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{plot_bar}\NormalTok{(pm)}
\end{Highlighting}
\end{Shaded}

\includegraphics{SEMINAR_SERIES_files/figure-latex/debar-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{plot_histogram}\NormalTok{(pm)}
\end{Highlighting}
\end{Shaded}

\includegraphics{SEMINAR_SERIES_files/figure-latex/phist-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{plot_boxplot}\NormalTok{(pm,}\DataTypeTok{by=}\StringTok{"diabetes"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{SEMINAR_SERIES_files/figure-latex/pbox-1.pdf}

\hypertarget{build-a-model---a-detailed-workflow}{%
\chapter{Build A Model - A Detailed Workflow}\label{build-a-model---a-detailed-workflow}}

The following graphic depicts the detailed steps involved in the typical Modeling Process. This is not the only way to proceed but it is used by many professional Data Scientists.

\includegraphics[width=\textwidth,height=6.25in]{./PICS/sworkflow.jpg}

\hypertarget{splitting-the-data}{%
\section{Splitting The Data}\label{splitting-the-data}}

A fundamental approach used in ML is to segment data into a ``training'' set which is some percentage of the original data - say 80\%. The remaining 20\% would be assigned to a ``test'' data set. Then we build a model on our training data set after which we use that model to predict outcomes for the test data set. This looks like the following.

\includegraphics[width=5.20833in,height=\textheight]{./PICS/train_test.png}

Note that some scenarios will split the data into three data sets: 1) training, 2) validation, and 3) test. This scenario is used when tuning so called hyper parameters for methods that have ``tuning'' parameters that could influence the resulting model. We'll stick with the basic ``train / test'' approach for now.

Splitting the data is not particularly challenging. We can use the built in \textbf{sample} function in R to do this. We aren't sampling with replacement here which guarantees that no record can exist in both sets. That is, if a record from the data set is assigned to the training set, it will not be in the test data set.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Make this example reproducible}
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{123}\NormalTok{) }
\NormalTok{percent <-}\StringTok{ }\FloatTok{.80}

\CommentTok{# Get the indices for a training set.}
\NormalTok{idx <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\KeywordTok{nrow}\NormalTok{(pm),}\KeywordTok{round}\NormalTok{(.}\DecValTok{8}\OperatorTok{*}\KeywordTok{nrow}\NormalTok{(pm)),F)}

\CommentTok{# Use bracket notation to create the train / test pair}
\NormalTok{train <-}\StringTok{ }\NormalTok{pm[idx,]}
\NormalTok{test  <-}\StringTok{ }\NormalTok{pm[}\OperatorTok{-}\NormalTok{idx,]}

\CommentTok{# The following should have 80 percent of the original }
\CommentTok{# data}

\KeywordTok{round}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(train)}\OperatorTok{/}\KeywordTok{nrow}\NormalTok{(pm)}\OperatorTok{*}\DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 80
\end{verbatim}

\hypertarget{first-model}{%
\section{First Model}\label{first-model}}

Now let's build a Generalized Linear Model to do the prediction. We will employ logistic regression.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myglm <-}\StringTok{ }\KeywordTok{glm}\NormalTok{(diabetes }\OperatorTok{~}\StringTok{ }\NormalTok{.,}
             \DataTypeTok{data =}\NormalTok{ train,}
             \DataTypeTok{family =} \StringTok{"binomial"}\NormalTok{)}

\KeywordTok{summary}\NormalTok{(myglm)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## Call:
## glm(formula = diabetes ~ ., family = "binomial", data = train)
## 
## Deviance Residuals: 
##     Min       1Q   Median       3Q      Max  
## -2.4798  -0.7300  -0.4281   0.7420   2.9493  
## 
## Coefficients:
##               Estimate Std. Error z value Pr(>|z|)    
## (Intercept) -8.2130001  0.7785903 -10.549  < 2e-16 ***
## pregnant     0.1183929  0.0357879   3.308 0.000939 ***
## glucose      0.0352638  0.0041847   8.427  < 2e-16 ***
## pressure    -0.0130875  0.0057262  -2.286 0.022281 *  
## triceps     -0.0009585  0.0075277  -0.127 0.898678    
## insulin     -0.0009091  0.0009840  -0.924 0.355526    
## mass         0.0860673  0.0166329   5.175 2.29e-07 ***
## pedigree     0.7810790  0.3211506   2.432 0.015010 *  
## age          0.0152288  0.0102926   1.480 0.138982    
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 796.42  on 613  degrees of freedom
## Residual deviance: 583.55  on 605  degrees of freedom
## AIC: 601.55
## 
## Number of Fisher Scoring iterations: 5
\end{verbatim}

In looking at the output we see some problems such as a number of predictors aren't significant so maybe we should eliminate them from the model. For now, we'll keep going because we are trying to outline the larger process / workflow.

\hypertarget{first-prediction}{%
\section{First Prediction}\label{first-prediction}}

\hypertarget{a-stumbling-block-for-new-comers}{%
\subsection{A Stumbling Block For New Comers}\label{a-stumbling-block-for-new-comers}}

We could now use this new model to predict outcomes using the test data set. Remember that we are attempting to predict a binary outcome - in this case whether the person is positive for diabetes or negative. What we get back from the prediction object are probabilities for which we have to determine a threshold above which we would say the observation is ``positive'' for diabetes and, below the threshold, ``negative''.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{probs <-}\StringTok{ }\KeywordTok{predict}\NormalTok{(myglm,}
                 \DataTypeTok{newdata =}\NormalTok{ test,}
                 \DataTypeTok{type =} \StringTok{"response"}\NormalTok{)}

\NormalTok{probs[}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##          1          3          9         17         22         27         28         32 
## 0.70756327 0.79695675 0.74524797 0.36330982 0.31803457 0.74106187 0.04892642 0.56777794 
##         42         43 
## 0.68427254 0.11927265
\end{verbatim}

With logistic regression we are dealing with a curve like the one below which is a sigmoid function. The idea is to take our probabilities, which range between 0 and 1, and then pick a threshold over which we would classify that person as being positive for diabetes. In this context, we have a continuum.

\includegraphics{SEMINAR_SERIES_files/figure-latex/logitplot-1.pdf}

\hypertarget{selecting-the-correct-alpha}{%
\subsection{Selecting The Correct Alpha}\label{selecting-the-correct-alpha}}

The temptation is to select 0.5 as the threshold such that if a returned probability exceeds 0.5 then we classify the associated subject as being ``positive'' for the disease. But then this assumes that the probabilities are distributed accordingly. This is frequently not the case though it doesn't stop people from using 0.5. Another way to view this is as follows. This graphic shows a ``perfect'' classifier which more or less matches the logit function above:

\includegraphics{./PICS/pc.png}

Note that this is a rare situation wherein our model has given us a clean separation between negative and positive cases. We could have something like this:

\includegraphics{./PICS/tnfp.png}

Or this:

\includegraphics{./PICS/sk2.png}

Or even this:

\includegraphics{./PICS/sk1.png}

One thing we should do here is to look at the distribution of the returned probabilities before making a decision about where to set the threshold. We can see clearly that selecting 0.5 in this case would not be appropriate.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{boxplot}\NormalTok{(probs, }
        \DataTypeTok{main=}\StringTok{"Probabilities from our GLM Model"}\NormalTok{)}
\KeywordTok{grid}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{SEMINAR_SERIES_files/figure-latex/bxplotalpha-1.pdf}

The median is somewhere around .25 so we could use that for now although we are just guessing.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mypreds <-}\StringTok{ }\KeywordTok{ifelse}\NormalTok{(probs }\OperatorTok{>}\StringTok{ }\FloatTok{0.25}\NormalTok{,}\StringTok{"pos"}\NormalTok{,}\StringTok{"neg"}\NormalTok{)}
\NormalTok{mypreds <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(mypreds, }\DataTypeTok{levels =} \KeywordTok{levels}\NormalTok{(test[[}\StringTok{"diabetes"}\NormalTok{]]))}
\NormalTok{mypreds[}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   1   3   9  17  22  27  28  32  42  43 
## pos pos pos pos pos pos neg pos pos neg 
## Levels: neg pos
\end{verbatim}

\hypertarget{confusion-matrices}{%
\subsection{Confusion Matrices}\label{confusion-matrices}}

Next, we would compare our predictions against the known outcomes which are stored in the test data frame:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# How does this compare to the truth ?}
\KeywordTok{table}\NormalTok{(}\DataTypeTok{predicted =}\NormalTok{ mypreds,}
      \DataTypeTok{actual =}\NormalTok{ test}\OperatorTok{$}\NormalTok{diabetes)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##          actual
## predicted neg pos
##       neg  66   9
##       pos  36  43
\end{verbatim}

What we are doing is building a ``Confusion Matrix'' which can help us determine how effective our model is. From such a matrix table we can compute a number of ``performance measures'', such as accuracy, precision, sensitivity, specificity and others, to help assess the quality of the model. In predictive modeling we are always interested in how well any given model will perform on ``new'' data.

There are some functions that can help us compute a confusion matrix. Because the variable we are trying to predict, (diabetes), is a two level factor, (``neg'' or ``pos'') we'll need to turn our predictions into a comparable factor. Right now, it's just a character string.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# test$diabetes <- ordered(test$diabetes,c("pos","neg"))}

\CommentTok{# mypreds <- factor(mypreds,}
 \CommentTok{#                 levels=levels(test$diabetes))}

\NormalTok{caret}\OperatorTok{::}\KeywordTok{confusionMatrix}\NormalTok{(mypreds,test}\OperatorTok{$}\NormalTok{diabetes,}\DataTypeTok{positive=}\StringTok{"pos"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Confusion Matrix and Statistics
## 
##           Reference
## Prediction neg pos
##        neg  66   9
##        pos  36  43
##                                           
##                Accuracy : 0.7078          
##                  95% CI : (0.6292, 0.7782)
##     No Information Rate : 0.6623          
##     P-Value [Acc > NIR] : 0.1335015       
##                                           
##                   Kappa : 0.4205          
##                                           
##  Mcnemar's Test P-Value : 0.0001063       
##                                           
##             Sensitivity : 0.8269          
##             Specificity : 0.6471          
##          Pos Pred Value : 0.5443          
##          Neg Pred Value : 0.8800          
##              Prevalence : 0.3377          
##          Detection Rate : 0.2792          
##    Detection Prevalence : 0.5130          
##       Balanced Accuracy : 0.7370          
##                                           
##        'Positive' Class : pos             
## 
\end{verbatim}

\hypertarget{performance-measures-revisited}{%
\section{Performance Measures Revisited}\label{performance-measures-revisited}}

This is helpful stuff although there are a number of measures to select as a primary performance metric. Ideally, we would already know which performance metric we would select to effectively ``judge'' the quality of our model. In medical tests, ``sensitivity'' and ``specificity'' are commonly used. Some applications use ``Accuracy'' (which isn't good when there is large group imbalance). Anyway, if, for example, we pick ``sensitivity'' as a judge of model quality we see that is somewhere around .87.
(A much deeper discussion about selecting the best performance measure is in order but we'll keep moving for now)

The problem here is that all we have done is looked at the confusion matrix corresponding to one specific (and arbitrary) threshold value when what we need is to look at a number of confusion matrices corresponding to many different thresholds. For example, we might get a better sensitivity level had we selected the mean of the returned probabilities. This process could go on and on and on\ldots{} So we would benefit from a rigorous approach to find the ``best'' threshold.

\hypertarget{the-roc-curve}{%
\section{The ROC curve}\label{the-roc-curve}}

One way to do this is to use something known as the ROC curve. Luckily, R has functions to do this. This isn't surprising as it is a standard tool that has been in use for decades long before the hype of AI and ML was around. The ROC curve gives us a ``one stop shop'' for estimating a value of alpha that results in maximal area under a curve.

In fact, maximizing the area under a given ROC curve winds up being an effective way to judge the differences between one method and another. So, if we wanted to compare the glm model against a Support Vector Machine model, we could use the respective AUC (Area Under Curve) metric to help us. This isn't the only way to do this but it's reasonable for now.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pred <-}\StringTok{ }\NormalTok{ROCR}\OperatorTok{::}\KeywordTok{prediction}\NormalTok{(}\DataTypeTok{predictions =}\NormalTok{ probs,}
                         \DataTypeTok{labels =}\NormalTok{ test}\OperatorTok{$}\NormalTok{diabetes)}

\NormalTok{perf <-}\StringTok{ }\KeywordTok{performance}\NormalTok{(pred,}
                    \StringTok{"tpr"}\NormalTok{,}
                    \StringTok{"fpr"}\NormalTok{)}
\KeywordTok{plot}\NormalTok{(perf,}\DataTypeTok{colorize=}\NormalTok{T,}
     \DataTypeTok{print.cutoffs.at=}\KeywordTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DataTypeTok{by=}\FloatTok{0.1}\NormalTok{),}
     \DataTypeTok{lwd=}\DecValTok{3}\NormalTok{,}\DataTypeTok{las=}\DecValTok{1}\NormalTok{,}\DataTypeTok{main=}\StringTok{"Cool ROC Curve"}\NormalTok{)}
\KeywordTok{abline}\NormalTok{(}\DataTypeTok{a =} \DecValTok{0}\NormalTok{, }\DataTypeTok{b =} \DecValTok{1}\NormalTok{)}

\KeywordTok{grid}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{SEMINAR_SERIES_files/figure-latex/rocrcalc-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myroc <-}\StringTok{ }\KeywordTok{performance}\NormalTok{(pred,}\DataTypeTok{measure=}\StringTok{"auc"}\NormalTok{)}
\NormalTok{myroc}\OperatorTok{@}\NormalTok{y.values[[}\DecValTok{1}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.8508673
\end{verbatim}

So what value of alpha corresponds to the stated max AUC of .80 ? We'll have to dig into the performance object to get that but it looks to be between 0.30 and 0.40. Note that this is somewhat academic since knowing the max AUC alone helps us decide if our model is any ``good''. For completeness we could use another R function to nail this down:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(pROC)}
\NormalTok{proc <-}\StringTok{ }\KeywordTok{roc}\NormalTok{(test}\OperatorTok{$}\NormalTok{diabetes,probs)}
\KeywordTok{round}\NormalTok{(}\KeywordTok{coords}\NormalTok{(proc, }\StringTok{"b"}\NormalTok{, }\DataTypeTok{ret=}\StringTok{"t"}\NormalTok{, }\DataTypeTok{transpose =} \OtherTok{FALSE}\NormalTok{),}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   threshold
## 1      0.36
\end{verbatim}

Generally speaking, here is a graphic which shows you some ROC curve shapes and how they relate to AUC.

\includegraphics{./PICS/multirocs.png}

\hypertarget{other-methods}{%
\chapter{Other Methods ?}\label{other-methods}}

Well, we could use another method to see if it yields better performance as determined by the AUC. Let's use the \textbf{ranger} function which is a fast implementation of random forests. One thing you will notice is that we need to include the ``probability'' argument in the call to ranger to get the necessary probabilities for computing the AUC. This is one of the aggravations with using different functions. They all have their own peculiar way of doing things.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(ranger)}
\NormalTok{ranger_mod <-}\StringTok{ }\KeywordTok{ranger}\NormalTok{(diabetes }\OperatorTok{~}\StringTok{ }\NormalTok{.,}
                   \DataTypeTok{data =}\NormalTok{ train,}
                   \DataTypeTok{probability =} \OtherTok{TRUE}\NormalTok{,}\DataTypeTok{mtry=}\DecValTok{4}\NormalTok{)}

\CommentTok{# Returns probabilities}
\NormalTok{ranger_pred <-}\StringTok{ }\KeywordTok{predict}\NormalTok{(ranger_mod,}\DataTypeTok{data=}\NormalTok{test)}

\NormalTok{myroc <-}\StringTok{ }\KeywordTok{roc}\NormalTok{(test}\OperatorTok{$}\NormalTok{diabetes,}
\NormalTok{             ranger_pred}\OperatorTok{$}\NormalTok{predictions[,}\DecValTok{2}\NormalTok{])}

\NormalTok{myroc}\OperatorTok{$}\NormalTok{auc}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Area under the curve: 0.8407
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pred <-}\StringTok{ }\NormalTok{ROCR}\OperatorTok{::}\KeywordTok{prediction}\NormalTok{(ranger_pred}\OperatorTok{$}\NormalTok{predictions[,}\DecValTok{2}\NormalTok{],}
\NormalTok{                         test}\OperatorTok{$}\NormalTok{diabetes)}
\NormalTok{perf <-}\StringTok{ }\KeywordTok{performance}\NormalTok{(pred,}
                    \StringTok{"tpr"}\NormalTok{,}
                    \StringTok{"fpr"}\NormalTok{)}
\KeywordTok{plot}\NormalTok{(perf,}\DataTypeTok{colorize=}\NormalTok{T,}
        \DataTypeTok{print.cutoffs.at=}\KeywordTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DataTypeTok{by=}\FloatTok{0.1}\NormalTok{),}
     \DataTypeTok{lwd=}\DecValTok{3}\NormalTok{,}\DataTypeTok{las=}\DecValTok{1}\NormalTok{,}\DataTypeTok{main=}\StringTok{"Cool ROC Curve"}\NormalTok{)}
\KeywordTok{abline}\NormalTok{(}\DataTypeTok{a =} \DecValTok{0}\NormalTok{, }\DataTypeTok{b =} \DecValTok{1}\NormalTok{)}

\KeywordTok{grid}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{SEMINAR_SERIES_files/figure-latex/range1-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rroc <-}\StringTok{ }\KeywordTok{performance}\NormalTok{(pred,}\DataTypeTok{measure=}\StringTok{"auc"}\NormalTok{)}
\NormalTok{rroc}\OperatorTok{@}\NormalTok{y.values[[}\DecValTok{1}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.8406863
\end{verbatim}

It turns out that this didn't appear to improve things - at least with one invocation of the method.

\hypertarget{improving-the-models}{%
\section{Improving The Model(s)}\label{improving-the-models}}

We haven't accomplished very much here because we need to look at multiple versions of the data in case we sampled a number of outliers in the creation of our training data. Or, maybe we have excluded a large number of outliers in the training set so they wound up in the test data set which means that the predictive power of our model isn't as robust as it should be.

Our next steps should involve creating multiple versions of the training and test pairs (say 3 times), compute the optimal AUC, and then look at how those values vary for each of those individual versions. If the AUCs vary widely then maybe our model is over training. If it's not varying widely, it could be that that the model has high bias.

\hypertarget{cross-fold-validation}{%
\section{Cross Fold Validation}\label{cross-fold-validation}}

This is a method that gives us multiple estimates of out-of-sample error, rather than a single estimate. In particular, we'll use an approach called ``K-Fold Cross Validation'' where we will partition our data into 3 individual ``folds''" which are basically equal in size. Then we'll create a loop that does the following:

\begin{itemize}
\tightlist
\item
  Combines 2 of the folds into a training data set
\item
  Builds a model on the combined 2-folds data
\item
  Applies the model to holdout fold
\item
  Computes the AUC value and stores it
\end{itemize}

Each fold is simply a portion of the data. We'll generate a list called ``folds'' that contains 3 elements each of which are 256 index elements corresponding to rows in pm. The way we did the sample insures that each row shows up only in one fold.

\includegraphics{./PICS/kf3.png}

Here is our function to implement the K-Fold validation. It's pretty straightforward to define in terms of coding though it winds up being somewhat specific to the particular method we are using. Still, we could give it an argument to accept different methods.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cross_fold <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{numofolds =} \DecValTok{3}\NormalTok{) \{}
  
  \CommentTok{# Function to Do Cross fold validation}
  
  \CommentTok{# Split the data into K folds (numofolds)}
  
\NormalTok{  folds <-}\StringTok{ }\KeywordTok{split}\NormalTok{(}\KeywordTok{sample}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\KeywordTok{nrow}\NormalTok{(pm)),}\DecValTok{1}\OperatorTok{:}\NormalTok{numofolds) }
  
  \CommentTok{# We setup some blank lists to stash results}
\NormalTok{  folddf    <-}\StringTok{ }\KeywordTok{list}\NormalTok{()  }\CommentTok{# Contains folds}
\NormalTok{  modl      <-}\StringTok{ }\KeywordTok{list}\NormalTok{()  }\CommentTok{# Hold each of the K models}
\NormalTok{  predl     <-}\StringTok{ }\KeywordTok{list}\NormalTok{()  }\CommentTok{# Hold rach of the K predictions}
\NormalTok{  auc       <-}\StringTok{ }\KeywordTok{list}\NormalTok{()  }\CommentTok{# Hold the auc for a given model}
  
  \CommentTok{# Create a formula that can be used across multiple}
  \CommentTok{# iterations through the loop. }
  
\NormalTok{  myform <-}\StringTok{ "diabetes ~ ."}
  
  \ControlFlowTok{for}\NormalTok{ (ii }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\KeywordTok{length}\NormalTok{(folds)) \{}
    
    \CommentTok{# This list holds the actual model we create for each of the }
    \CommentTok{# 10 folds}
    
\NormalTok{    modl[[ii]] <-}\StringTok{ }\KeywordTok{glm}\NormalTok{(}\DataTypeTok{formula =}\NormalTok{ myform, }
                      \DataTypeTok{data =}\NormalTok{ pm[}\OperatorTok{-}\NormalTok{folds[[ii]],],}
                      \DataTypeTok{family =} \StringTok{"binomial"}
\NormalTok{    )}
    
    \CommentTok{# This list will contain / hold the models build on the fold}
    
\NormalTok{    predl[[ii]]  <-}\StringTok{ }\KeywordTok{predict}\NormalTok{(modl[[ii]],}
                            \DataTypeTok{newdata=}\NormalTok{pm[folds[[ii]],],}
                            \DataTypeTok{type=}\StringTok{"response"}\NormalTok{)}
    
    \CommentTok{# This list will hold the results of the AUC per iteration}
    
\NormalTok{    pred <-}\StringTok{ }\NormalTok{ROCR}\OperatorTok{::}\KeywordTok{prediction}\NormalTok{(predl[[ii]],}
\NormalTok{                             pm[folds[[ii]],]}\OperatorTok{$}\NormalTok{diabetes)}
    
\NormalTok{    roc  <-}\StringTok{ }\KeywordTok{performance}\NormalTok{(pred,}\DataTypeTok{measure=}\StringTok{"auc"}\NormalTok{)}
\NormalTok{    auc[[ii]] <-}\StringTok{ }\NormalTok{roc}\OperatorTok{@}\NormalTok{y.values[[}\DecValTok{1}\NormalTok{]]}
\NormalTok{  \}}
  \KeywordTok{return}\NormalTok{(}\KeywordTok{unlist}\NormalTok{(auc))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Running this is now quite simple. By default, this function will loop three times corresponding to the number of folds. During each iteration it will:

\begin{itemize}
\tightlist
\item
  use glm to build a model on the training folds
\item
  create a prediction object using the training fold
\item
  compute the underlying AUC associated with the prediction
\item
  store the AUC in a vector
\end{itemize}

At the end of the function, the vector containing the computed AUCs will be returned.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{123}\NormalTok{)}
\KeywordTok{cross_fold}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.8537200 0.8290205 0.7944576
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Use more folds}
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{123}\NormalTok{)}
\KeywordTok{cross_fold}\NormalTok{(}\DecValTok{8}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.8674473 0.8032407 0.7715248 0.8680715 0.7972689 0.8523886 0.8361111 0.8111111
\end{verbatim}

We could take the average of the AUCs to get a sense of how well this method would apply to unseen data.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{123}\NormalTok{)}
\KeywordTok{mean}\NormalTok{(}\KeywordTok{cross_fold}\NormalTok{(}\DecValTok{8}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.8258955
\end{verbatim}

Let's plot the individual values:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{stripplot}\NormalTok{(}\KeywordTok{cross_fold}\NormalTok{(}\DecValTok{8}\NormalTok{),}
          \DataTypeTok{main=}\StringTok{"AUC values for K-Fold Validation"}\NormalTok{,}
          \DataTypeTok{type=}\KeywordTok{c}\NormalTok{(}\StringTok{"g"}\NormalTok{,}\StringTok{"p"}\NormalTok{),}\DataTypeTok{pch=}\DecValTok{19}\NormalTok{,}\DataTypeTok{cex=}\FloatTok{1.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{SEMINAR_SERIES_files/figure-latex/strip1-1.pdf}

So, there are functions in R that will implement K-fold cross-validation for you but they involve their own specific interface. There is the ``cv.glm'' function which does cross validation on GLM models. There is also the ``bagging.cv'' function tht does the same with Bagging.

\hypertarget{is-there-a-better-way}{%
\chapter{Is There a Better Way ?}\label{is-there-a-better-way}}

In R, as well as with Python, there are a growing number of packages available to help simplify repetitive processes. Building predictive models is no exception especially given that so many sub processes are involved such as splitting data, building a model, making a prediction, comparing it to the labelled data, and so on. The \textbf{caret} package provides an easy point of entry into the world of predictive modeling. It provides the following features:

\begin{verbatim}
- Streamlined and consistent syntax for more than 
  200 different models
- Can implement any of the 238 different methods using a single function
- Easy data splitting to simplify the creation of train / test pairs
- Realistic model estimates through built-in resampling
- Convenient feature importance determination
- Easy selection of different performance metrics (e.g. "ROC","Accuracy", "Sensitivity")
- Automated and semi-automated parameter tuning
- Simplifed comparison of different models
\end{verbatim}

The caret package was designed specifically for predictive modeling and, in particular, to provide an intuitive approach to creating, managing, and comparing different models emerging from various methods. Let's work through our previous examples using functions from \textbf{caret}.

\hypertarget{data-splitting-using-caret}{%
\section{Data Splitting Using Caret}\label{data-splitting-using-caret}}

Let's split the data into a training / test pair. The caret package provides some useful functions for this one of which is the \textbf{CreateDataPartition} function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{idx <-}\StringTok{ }\KeywordTok{createDataPartition}\NormalTok{(pm}\OperatorTok{$}\NormalTok{diabetes,}
                           \DataTypeTok{p=}\NormalTok{.}\DecValTok{80}\NormalTok{,}
                           \DataTypeTok{list=}\OtherTok{FALSE}\NormalTok{)}

\NormalTok{Train <-}\StringTok{ }\NormalTok{pm[idx,]}
\NormalTok{Test  <-}\StringTok{ }\NormalTok{pm[}\OperatorTok{-}\NormalTok{idx,]}

\KeywordTok{nrow}\NormalTok{(Train)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 615
\end{verbatim}

Now we can use this to create a training object with caret. We'll create a GLM model similar to the one we've already created. The primary, and most frequently used, function in \textbf{caret} is the \textbf{train} function. In this example we'll use it build a model using the \textbf{glm} method. We will also specify that ``Accuracy'' will be the preferred performance measure.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myglm_caret <-}\StringTok{ }\KeywordTok{train}\NormalTok{(diabetes }\OperatorTok{~}\StringTok{ }\NormalTok{.,}
                     \DataTypeTok{data =}\NormalTok{ Train,}
                     \DataTypeTok{method =} \StringTok{"glm"}\NormalTok{,}
                     \DataTypeTok{metric =} \StringTok{"Accuracy"}\NormalTok{)}
\NormalTok{myglm_caret}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Generalized Linear Model 
## 
## 615 samples
##   8 predictor
##   2 classes: 'neg', 'pos' 
## 
## No pre-processing
## Resampling: Bootstrapped (25 reps) 
## Summary of sample sizes: 615, 615, 615, 615, 615, 615, ... 
## Resampling results:
## 
##   Accuracy   Kappa    
##   0.7590927  0.4449503
\end{verbatim}

We get a lot for our money. Look at all the stuff we get in the returned object:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(myglm_caret,}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## List of 23
##  $ method      : chr "glm"
##  $ modelInfo   :List of 15
##  $ modelType   : chr "Classification"
##  $ results     :'data.frame':    1 obs. of  5 variables:
##  $ pred        : NULL
##  $ bestTune    :'data.frame':    1 obs. of  1 variable:
##  $ call        : language train.formula(form = diabetes ~ ., data = Train, method = "glm", metric = "Accuracy")
##  $ dots        : list()
##  $ metric      : chr "Accuracy"
##  $ control     :List of 27
##  $ finalModel  :List of 34
##   ..- attr(*, "class")= chr [1:2] "glm" "lm"
##  $ preProcess  : NULL
##  $ trainingData:'data.frame':    615 obs. of  9 variables:
##  $ resample    :'data.frame':    25 obs. of  3 variables:
##  $ resampledCM :'data.frame':    25 obs. of  6 variables:
##  $ perfNames   : chr [1:2] "Accuracy" "Kappa"
##  $ maximize    : logi TRUE
##  $ yLimits     : NULL
##  $ times       :List of 3
##  $ levels      : chr [1:2] "neg" "pos"
##   ..- attr(*, "ordered")= logi FALSE
##  $ terms       :Classes 'terms', 'formula'  language diabetes ~ pregnant + glucose + pressure + triceps + insulin + mass + pedigree + age
##   .. ..- attr(*, "variables")= language list(diabetes, pregnant, glucose, pressure, triceps, insulin, mass, pedigree, age)
##   .. ..- attr(*, "factors")= int [1:9, 1:8] 0 1 0 0 0 0 0 0 0 0 ...
##   .. .. ..- attr(*, "dimnames")=List of 2
##   .. ..- attr(*, "term.labels")= chr [1:8] "pregnant" "glucose" "pressure" "triceps" ...
##   .. ..- attr(*, "order")= int [1:8] 1 1 1 1 1 1 1 1
##   .. ..- attr(*, "intercept")= int 1
##   .. ..- attr(*, "response")= int 1
##   .. ..- attr(*, ".Environment")=<environment: R_GlobalEnv> 
##   .. ..- attr(*, "predvars")= language list(diabetes, pregnant, glucose, pressure, triceps, insulin, mass, pedigree, age)
##   .. ..- attr(*, "dataClasses")= Named chr [1:9] "factor" "numeric" "numeric" "numeric" ...
##   .. .. ..- attr(*, "names")= chr [1:9] "diabetes" "pregnant" "glucose" "pressure" ...
##  $ coefnames   : chr [1:8] "pregnant" "glucose" "pressure" "triceps" ...
##  $ xlevels     : Named list()
##  - attr(*, "class")= chr [1:2] "train" "train.formula"
\end{verbatim}

\hypertarget{specifying-control-options}{%
\section{Specifying Control Options}\label{specifying-control-options}}

We can even request cross fold validation without having to write our own function to do this. To do this requires the specification of a ``control'' object which contains information that we would like for the \textbf{train} function to consider as it does its work.

Not every invocation of \textbf{train} requires an associated \textbf{trainControl} object although as you become more experienced building models, you will frequently use this approach.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{control <-}\StringTok{ }\KeywordTok{trainControl}\NormalTok{(}\DataTypeTok{method =} \StringTok{"cv"}\NormalTok{, }\DataTypeTok{number =} \DecValTok{5}\NormalTok{)}

\NormalTok{myglm_caret <-}\StringTok{ }\KeywordTok{train}\NormalTok{(diabetes }\OperatorTok{~}\StringTok{ }\NormalTok{.,}
                     \DataTypeTok{data =}\NormalTok{ Train,}
                     \DataTypeTok{method =} \StringTok{"glm"}\NormalTok{,}
                     \DataTypeTok{metric =} \StringTok{"Accuracy"}\NormalTok{,}
                     \DataTypeTok{trControl =}\NormalTok{ control)}
\NormalTok{myglm_caret}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Generalized Linear Model 
## 
## 615 samples
##   8 predictor
##   2 classes: 'neg', 'pos' 
## 
## No pre-processing
## Resampling: Cross-Validated (5 fold) 
## Summary of sample sizes: 492, 492, 492, 492, 492 
## Resampling results:
## 
##   Accuracy   Kappa    
##   0.7642276  0.4587416
\end{verbatim}

\hypertarget{inspecting-the-model}{%
\section{Inspecting The Model}\label{inspecting-the-model}}

The object returned by caret has a great deal of information packed into it much of which is there to support reproducibility. Some key aspects of the object include, in this case, the Accuracy computation for each fold.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myglm_caret}\OperatorTok{$}\NormalTok{resample}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    Accuracy     Kappa Resample
## 1 0.7967480 0.5249498    Fold1
## 2 0.7154472 0.3424469    Fold2
## 3 0.7642276 0.4551703    Fold3
## 4 0.7723577 0.4884135    Fold4
## 5 0.7723577 0.4827275    Fold5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myglm_caret}\OperatorTok{$}\NormalTok{results}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   parameter  Accuracy     Kappa AccuracySD    KappaSD
## 1      none 0.7642276 0.4587416 0.02987183 0.06959971
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Note that the final reported Accuracy metric is simply the average of }
\CommentTok{# the reported Accuracy values for each fold}

\NormalTok{myglm_caret}\OperatorTok{$}\NormalTok{results[}\DecValTok{2}\NormalTok{] }\OperatorTok{==}\StringTok{ }\KeywordTok{mean}\NormalTok{(myglm_caret}\OperatorTok{$}\NormalTok{resample}\OperatorTok{$}\NormalTok{Accuracy)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   Accuracy
## 1     TRUE
\end{verbatim}

Of course, you can always look at the model itself to get summary information just as you could if you were not using the \textbf{train} function. That is, the \textbf{caret} package does not try to conceal or replace what could be done using standard approaches. It overlays the model with information in a way that is transparent.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{summary}\NormalTok{(myglm_caret)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## Call:
## NULL
## 
## Deviance Residuals: 
##     Min       1Q   Median       3Q      Max  
## -2.5895  -0.7228  -0.4200   0.7493   2.8819  
## 
## Coefficients:
##               Estimate Std. Error z value Pr(>|z|)    
## (Intercept) -8.0138799  0.7810199 -10.261  < 2e-16 ***
## pregnant     0.1345055  0.0351085   3.831 0.000128 ***
## glucose      0.0338195  0.0040410   8.369  < 2e-16 ***
## pressure    -0.0143664  0.0058480  -2.457 0.014025 *  
## triceps      0.0014291  0.0076069   0.188 0.850981    
## insulin     -0.0006469  0.0009943  -0.651 0.515327    
## mass         0.0886847  0.0164204   5.401 6.63e-08 ***
## pedigree     0.8552509  0.3347542   2.555 0.010623 *  
## age          0.0101666  0.0104009   0.977 0.328334    
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 796.05  on 614  degrees of freedom
## Residual deviance: 586.22  on 606  degrees of freedom
## AIC: 604.22
## 
## Number of Fisher Scoring iterations: 5
\end{verbatim}

\hypertarget{how-well-did-it-perform}{%
\section{How Well Did It Perform ?}\label{how-well-did-it-perform}}

Remember that one of the features of using caret is that it can help us estimate the out of sample error we will experience when applying our model to new or unseen data. The above model provides an estimate of out of band accuracy as .77

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myglm_caret}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Generalized Linear Model 
## 
## 615 samples
##   8 predictor
##   2 classes: 'neg', 'pos' 
## 
## No pre-processing
## Resampling: Cross-Validated (5 fold) 
## Summary of sample sizes: 492, 492, 492, 492, 492 
## Resampling results:
## 
##   Accuracy   Kappa    
##   0.7642276  0.4587416
\end{verbatim}

Let's create a prediction object using the Test data to see how close we came to this estimate. It's a little worse than caret's estimate which is to be expected. Also, this is just an estimate using a single threshold when using the predict function. There are more sophisticated ways to estimate the accuracy.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mypreds_glm <-}\StringTok{ }\KeywordTok{predict}\NormalTok{(myglm_caret, Test)}

\CommentTok{# Create a Table of known outcomes vs the predicted outcomes}
\NormalTok{outcome <-}\StringTok{ }\KeywordTok{table}\NormalTok{(}\DataTypeTok{preds=}\NormalTok{mypreds_glm,}\DataTypeTok{actual=}\NormalTok{Test}\OperatorTok{$}\NormalTok{diabetes)}

\NormalTok{(acc_outcome <-}\StringTok{ }\KeywordTok{sum}\NormalTok{(}\KeywordTok{diag}\NormalTok{(outcome))}\OperatorTok{/}\KeywordTok{sum}\NormalTok{(outcome))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.7973856
\end{verbatim}

\hypertarget{comparing-performance-across-other-methods}{%
\section{Comparing Performance Across Other Methods}\label{comparing-performance-across-other-methods}}

The advantage of the \textbf{train} function is that we can use the same control objects across a number of modeling techniques which then makes it easier to compare performance across various methods.

As an example, instead of using the ``glm'' method we could pick another one such as Decision Tree. All we need to know is the name of the method we want. A complete list of supported models listed by category can be found \href{https://topepo.github.io/caret/available-models.html}{here}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{control <-}\StringTok{ }\KeywordTok{trainControl}\NormalTok{(}\DataTypeTok{method =} \StringTok{"cv"}\NormalTok{, }\DataTypeTok{number =} \DecValTok{5}\NormalTok{)}

\NormalTok{myrpart_caret <-}\StringTok{ }\KeywordTok{train}\NormalTok{(diabetes }\OperatorTok{~}\StringTok{ }\NormalTok{.,}
                     \DataTypeTok{data =}\NormalTok{ Train,}
                     \DataTypeTok{method =} \StringTok{"rpart"}\NormalTok{,}
                     \DataTypeTok{metric =} \StringTok{"Accuracy"}\NormalTok{,}
                     \DataTypeTok{trControl =}\NormalTok{ control)}
\NormalTok{myrpart_caret}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## CART 
## 
## 615 samples
##   8 predictor
##   2 classes: 'neg', 'pos' 
## 
## No pre-processing
## Resampling: Cross-Validated (5 fold) 
## Summary of sample sizes: 492, 492, 492, 492, 492 
## Resampling results across tuning parameters:
## 
##   cp          Accuracy   Kappa    
##   0.02093023  0.7284553  0.3931155
##   0.11162791  0.7154472  0.3492746
##   0.23720930  0.6991870  0.2679068
## 
## Accuracy was used to select the optimal model using the largest value.
## The final value used for the model was cp = 0.02093023.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myrpart_caret_preds =}\StringTok{ }\KeywordTok{predict}\NormalTok{(myrpart_caret,Test)}
\end{Highlighting}
\end{Shaded}

So we also need to do some predictions on the Test data set to see how well the model works on unseen data. This model has good specifity but not so good with the sensitivity.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{confusionMatrix}\NormalTok{(myrpart_caret_preds,Test}\OperatorTok{$}\NormalTok{diabetes,}\DataTypeTok{positive=}\StringTok{"pos"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Confusion Matrix and Statistics
## 
##           Reference
## Prediction neg pos
##        neg  88  23
##        pos  12  30
##                                           
##                Accuracy : 0.7712          
##                  95% CI : (0.6965, 0.8352)
##     No Information Rate : 0.6536          
##     P-Value [Acc > NIR] : 0.001098        
##                                           
##                   Kappa : 0.4689          
##                                           
##  Mcnemar's Test P-Value : 0.090969        
##                                           
##             Sensitivity : 0.5660          
##             Specificity : 0.8800          
##          Pos Pred Value : 0.7143          
##          Neg Pred Value : 0.7928          
##              Prevalence : 0.3464          
##          Detection Rate : 0.1961          
##    Detection Prevalence : 0.2745          
##       Balanced Accuracy : 0.7230          
##                                           
##        'Positive' Class : pos             
## 
\end{verbatim}

This method employs a Decision Tree approach which also involves use of ``hyper parameters''. However, at this point we don't really need to know much about those (although we should) when selecting the method. The larger point is that all we need to know is the name of the alternative method and we can reuse the previous \textbf{control} object.

\hypertarget{different-performance-measures}{%
\section{Different Performance Measures}\label{different-performance-measures}}

Not only can we easily select different methods we can also select different performance measures. It does require changes to the control object and arguments to the \textbf{train} function though we do not need to read the underlying help pages for a given method to do this. This is a true convenience and time saver that makes reproducing these experiments much easier.

In this example we want to use the ``Area Under Curve'' (AUC) metric that comes from an associated ROC curve. To do this will require the model to generate class probabilities from which to build the ROC curve so this information needs to be specified in the control object.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{control <-}\StringTok{ }\KeywordTok{trainControl}\NormalTok{(}\DataTypeTok{classProbs =} \OtherTok{TRUE}\NormalTok{,}
                        \DataTypeTok{summaryFunction =}\NormalTok{ twoClassSummary,}
                        \DataTypeTok{method =} \StringTok{"cv"}\NormalTok{,}
                        \DataTypeTok{number =} \DecValTok{8}\NormalTok{)}

\NormalTok{myglm_caret_roc <-}\StringTok{ }\KeywordTok{train}\NormalTok{(diabetes }\OperatorTok{~}\StringTok{ }\NormalTok{.,}
                         \DataTypeTok{data =}\NormalTok{ Train,}
                         \DataTypeTok{method =} \StringTok{"glm"}\NormalTok{,}
                         \DataTypeTok{metric =} \StringTok{"ROC"}\NormalTok{,}
                         \DataTypeTok{trControl =}\NormalTok{ control)}

\NormalTok{myglm_caret_roc}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Generalized Linear Model 
## 
## 615 samples
##   8 predictor
##   2 classes: 'neg', 'pos' 
## 
## No pre-processing
## Resampling: Cross-Validated (8 fold) 
## Summary of sample sizes: 538, 538, 538, 538, 538, 538, ... 
## Resampling results:
## 
##   ROC        Sens  Spec     
##   0.8293661  0.88  0.5532407
\end{verbatim}

This is a true convenience and we don't have to use a separate R package to compute the AUC. It becomes a by product of the modeling process. One subtlety with the above is the way caret looks at the levels of the diabetes column. It looks at them as ``neg'' and ``pos'' which leads to a switch between the sensitivity and specificity. An example will make this clear. Let's do predictions on the training data:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{train_myglm_preds <-}\StringTok{ }\KeywordTok{predict}\NormalTok{(myglm_caret_roc,Train)}
\NormalTok{caret}\OperatorTok{::}\KeywordTok{confusionMatrix}\NormalTok{(train_myglm_preds,Train}\OperatorTok{$}\NormalTok{diabetes,}\DataTypeTok{positive=}\StringTok{"pos"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Confusion Matrix and Statistics
## 
##           Reference
## Prediction neg pos
##        neg 351  92
##        pos  49 123
##                                           
##                Accuracy : 0.7707          
##                  95% CI : (0.7354, 0.8034)
##     No Information Rate : 0.6504          
##     P-Value [Acc > NIR] : 6.565e-11       
##                                           
##                   Kappa : 0.4714          
##                                           
##  Mcnemar's Test P-Value : 0.0004046       
##                                           
##             Sensitivity : 0.5721          
##             Specificity : 0.8775          
##          Pos Pred Value : 0.7151          
##          Neg Pred Value : 0.7923          
##              Prevalence : 0.3496          
##          Detection Rate : 0.2000          
##    Detection Prevalence : 0.2797          
##       Balanced Accuracy : 0.7248          
##                                           
##        'Positive' Class : pos             
## 
\end{verbatim}

Let's see how it performs on the Test data

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{test_myglm_preds <-}\StringTok{ }\KeywordTok{predict}\NormalTok{(myglm_caret_roc,Test)}
\NormalTok{caret}\OperatorTok{::}\KeywordTok{confusionMatrix}\NormalTok{(test_myglm_preds,Test}\OperatorTok{$}\NormalTok{diabetes,}\DataTypeTok{positive=}\StringTok{"pos"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Confusion Matrix and Statistics
## 
##           Reference
## Prediction neg pos
##        neg  89  20
##        pos  11  33
##                                          
##                Accuracy : 0.7974         
##                  95% CI : (0.7249, 0.858)
##     No Information Rate : 0.6536         
##     P-Value [Acc > NIR] : 7.169e-05      
##                                          
##                   Kappa : 0.5339         
##                                          
##  Mcnemar's Test P-Value : 0.1508         
##                                          
##             Sensitivity : 0.6226         
##             Specificity : 0.8900         
##          Pos Pred Value : 0.7500         
##          Neg Pred Value : 0.8165         
##              Prevalence : 0.3464         
##          Detection Rate : 0.2157         
##    Detection Prevalence : 0.2876         
##       Balanced Accuracy : 0.7563         
##                                          
##        'Positive' Class : pos            
## 
\end{verbatim}

Specifically, the control object can remain the same across different methods assuming that we wish to continue with classification. Here, we'll use Random Forests which are a generalization beyond a single Decision Tree.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# The following is the same control object from before}
\NormalTok{control <-}\StringTok{ }\KeywordTok{trainControl}\NormalTok{(}\DataTypeTok{classProbs =} \OtherTok{TRUE}\NormalTok{,}
                        \DataTypeTok{summaryFunction =}\NormalTok{ twoClassSummary,}
                        \DataTypeTok{method =} \StringTok{"cv"}\NormalTok{,}
                        \DataTypeTok{number =} \DecValTok{8}\NormalTok{)}
\CommentTok{# We'll }
\NormalTok{myrf_caret <-}\StringTok{ }\KeywordTok{train}\NormalTok{(diabetes }\OperatorTok{~}\StringTok{ }\NormalTok{.,}
               \DataTypeTok{data =}\NormalTok{ Train,}
 \CommentTok{#              method = "svmLinear",}
               \DataTypeTok{method =} \StringTok{"rf"}\NormalTok{,}
               \DataTypeTok{metric =} \StringTok{"ROC"}\NormalTok{,}
               \DataTypeTok{trControl =}\NormalTok{ control)}

\NormalTok{myrf_caret}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Random Forest 
## 
## 615 samples
##   8 predictor
##   2 classes: 'neg', 'pos' 
## 
## No pre-processing
## Resampling: Cross-Validated (8 fold) 
## Summary of sample sizes: 538, 538, 538, 538, 538, 539, ... 
## Resampling results across tuning parameters:
## 
##   mtry  ROC        Sens    Spec     
##   2     0.8146581  0.8300  0.5997151
##   5     0.8105413  0.8300  0.6045228
##   8     0.8091738  0.8275  0.6043447
## 
## ROC was used to select the optimal model using the largest value.
## The final value used for the model was mtry = 2.
\end{verbatim}

\hypertarget{feature-importance}{%
\chapter{Feature Importance}\label{feature-importance}}

Another advantage of using the caret \textbf{train} function is that it provides a method to determine variable importance. This is useful when considering what features to include or not when building a model. If we summarize a given model, our myglm\_caret model, we'll see that some of our predictors are not significant.

We could use the \textbf{varImp} to use statistics generated by the specific modeling process itself. For more complex modeling techniques this winds up being very useful since digging into the model diagnostics can be daunting - although quite useful.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{varImp}\NormalTok{(myglm_caret)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## glm variable importance
## 
##          Overall
## glucose  100.000
## mass      63.719
## pregnant  44.532
## pedigree  28.932
## pressure  27.731
## age        9.651
## insulin    5.656
## triceps    0.000
\end{verbatim}

If you wanted to see how the different models rates the significance of predictor variables then you can easily plot them.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(gridExtra)}
\NormalTok{p1 <-}\StringTok{ }\KeywordTok{plot}\NormalTok{(}\KeywordTok{varImp}\NormalTok{(myglm_caret),}\DataTypeTok{main=}\StringTok{"varImp for glm"}\NormalTok{)}
\NormalTok{p2 <-}\StringTok{ }\KeywordTok{plot}\NormalTok{(}\KeywordTok{varImp}\NormalTok{(myrf_caret),}\DataTypeTok{main=}\StringTok{"varImp for Rf"}\NormalTok{)}
\KeywordTok{grid.arrange}\NormalTok{(p1,p2,}\DataTypeTok{ncol=}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{SEMINAR_SERIES_files/figure-latex/plotfeat-1.pdf}

\hypertarget{feature-elimination}{%
\subsection{Feature Elimination}\label{feature-elimination}}

The caret package also supports ``recursive feature elimination'' which automates the selection of optimal features. This can be controversial since such a process could work at the expense of important statistical considerations. However, it remains a tool in the Machine Learning toolbox.

Let's work though an example of this using caret functions. First, we'll remove highly correlated predictor variables from consideration. We don't really have a lot of highly correlated variables. It turns out that ``age'' is correlated with ``pregnant'' at a level of 0.54.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{plot_correlation}\NormalTok{(pm[,}\DecValTok{1}\OperatorTok{:}\DecValTok{8}\NormalTok{], }\DataTypeTok{type=}\StringTok{"continuous"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{SEMINAR_SERIES_files/figure-latex/elimfeat-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# find attributes that exceed some spcified threshold}
\NormalTok{highlyCorrelated <-}\StringTok{ }\KeywordTok{findCorrelation}\NormalTok{(}\KeywordTok{cor}\NormalTok{(pm[,}\DecValTok{1}\OperatorTok{:}\DecValTok{8}\NormalTok{]),}
                                    \DataTypeTok{cutoff=}\FloatTok{0.5}\NormalTok{,}
                                    \DataTypeTok{names =} \OtherTok{TRUE}\NormalTok{)}

\CommentTok{# print indexes of highly correlated attributes}
\KeywordTok{print}\NormalTok{(highlyCorrelated)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "age"
\end{verbatim}

\hypertarget{the-rfe-function}{%
\subsection{The rfe Function}\label{the-rfe-function}}

Let's apply the RFE method on the Pima Indians Diabetes data set. The algorithm is configured to explore all possible subsets of the attributes. All 8 attributes are selected in this example, although in the plot showing the accuracy of the different attribute subset sizes, we can see that just 4 attributes gives almost comparable results

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rfFuncs}\OperatorTok{$}\NormalTok{summary <-}\StringTok{ }\NormalTok{twoClassSummary}
\NormalTok{control <-}\StringTok{ }\KeywordTok{rfeControl}\NormalTok{(}\DataTypeTok{functions=}\NormalTok{rfFuncs, }
                      \DataTypeTok{method=}\StringTok{"cv"}\NormalTok{, }
                      \DataTypeTok{number=}\DecValTok{4}\NormalTok{)}

\CommentTok{# run the RFE algorithm}
\NormalTok{results <-}\StringTok{ }\KeywordTok{rfe}\NormalTok{(pm[,}\DecValTok{1}\OperatorTok{:}\DecValTok{8}\NormalTok{], }
\NormalTok{               pm[,}\DecValTok{9}\NormalTok{], }
               \DataTypeTok{sizes=}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{8}\NormalTok{), }
               \DataTypeTok{rfeControl=}\NormalTok{control,}
               \DataTypeTok{metric=}\StringTok{"ROC"}\NormalTok{)}

\CommentTok{# summarize the results}
\KeywordTok{print}\NormalTok{(results)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## Recursive feature selection
## 
## Outer resampling method: Cross-Validated (4 fold) 
## 
## Resampling performance over subset size:
## 
##  Variables    ROC  Sens   Spec   ROCSD   SensSD  SpecSD Selected
##          1 0.7244 0.852 0.4179 0.02110 0.008000 0.01219         
##          2 0.7687 0.830 0.5224 0.01022 0.035402 0.04222         
##          3 0.7966 0.834 0.5522 0.01954 0.036000 0.05170         
##          4 0.8067 0.838 0.5746 0.02375 0.007659 0.04478         
##          5 0.8130 0.842 0.5410 0.02846 0.030898 0.06716         
##          6 0.8206 0.844 0.5784 0.03239 0.034871 0.06139         
##          7 0.8202 0.848 0.5448 0.03241 0.041825 0.04640         
##          8 0.8272 0.858 0.5821 0.03646 0.030199 0.03656        *
## 
## The top 5 variables (out of 8):
##    glucose, mass, age, pregnant, pedigree
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# list the chosen features}
\KeywordTok{predictors}\NormalTok{(results)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "glucose"  "mass"     "age"      "pregnant" "pedigree" "insulin"  "triceps"  "pressure"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# plot the results}
\KeywordTok{plot}\NormalTok{(results, }\DataTypeTok{type=}\KeywordTok{c}\NormalTok{(}\StringTok{"g"}\NormalTok{, }\StringTok{"o"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\includegraphics{SEMINAR_SERIES_files/figure-latex/rfe1-1.pdf}

\hypertarget{comparing-models}{%
\chapter{Comparing Models}\label{comparing-models}}

One of the more frequent activities in Machine Learning relates to setting up ``shoot outs'' between different models to see which one will perform the best. This is something we could do without \textbf{caret} but the package does help accomplish this using a standard interface. We'll keep using the Pima Indians Data and (re)build a few models. We'll use a common \textbf{control} object as well as a seed to maintain reproducibility.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{control <-}\StringTok{ }\KeywordTok{trainControl}\NormalTok{(}\DataTypeTok{method=}\StringTok{"cv"}\NormalTok{, }
                        \DataTypeTok{number=}\DecValTok{5}\NormalTok{, }
                        \DataTypeTok{summaryFunction =}\NormalTok{ twoClassSummary,}
                        \DataTypeTok{classProbs =} \OtherTok{TRUE}\NormalTok{)}

\CommentTok{# Train the glm model}
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{7}\NormalTok{)}
\NormalTok{model_glm <-}\StringTok{ }\KeywordTok{train}\NormalTok{(diabetes }\OperatorTok{~}\StringTok{ }\NormalTok{., }
                   \DataTypeTok{data=}\NormalTok{pm, }
                   \DataTypeTok{method=}\StringTok{"glm"}\NormalTok{, }
                   \DataTypeTok{metric=}\StringTok{"ROC"}\NormalTok{,}
                   \DataTypeTok{trControl=}\NormalTok{control)}

\CommentTok{# Train the Decision Tree <odel}
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{7}\NormalTok{)}
\NormalTok{model_rpart <-}\StringTok{ }\KeywordTok{train}\NormalTok{(diabetes}\OperatorTok{~}\NormalTok{., }
                  \DataTypeTok{data=}\NormalTok{pm, }
                  \DataTypeTok{method=}\StringTok{"rpart"}\NormalTok{, }
                  \DataTypeTok{metric=}\StringTok{"ROC"}\NormalTok{,}
                  \DataTypeTok{trControl=}\NormalTok{control)}

\CommentTok{# Train the Random Forest model}
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{7}\NormalTok{)}
\NormalTok{model_rf <-}\StringTok{ }\KeywordTok{train}\NormalTok{(diabetes}\OperatorTok{~}\NormalTok{., }
                  \DataTypeTok{data=}\NormalTok{pm, }
                  \DataTypeTok{method=}\StringTok{"rf"}\NormalTok{, }
                  \DataTypeTok{metric=}\StringTok{"ROC"}\NormalTok{,}
                  \DataTypeTok{trControl=}\NormalTok{control)}

\CommentTok{# Train the knn model}
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{7}\NormalTok{)}
\NormalTok{model_knn <-}\StringTok{ }\KeywordTok{train}\NormalTok{(diabetes}\OperatorTok{~}\NormalTok{., }
                  \DataTypeTok{data=}\NormalTok{pm, }
                  \DataTypeTok{method=}\StringTok{"knn"}\NormalTok{, }
                  \DataTypeTok{metric=}\StringTok{"ROC"}\NormalTok{,}
                  \DataTypeTok{trControl=}\NormalTok{control)}

\CommentTok{# Use the resamples function to prep for comparisons}
\NormalTok{results <-}\StringTok{ }\KeywordTok{resamples}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DataTypeTok{GLM   =}\NormalTok{ model_glm, }
                          \DataTypeTok{RPART =}\NormalTok{ model_rpart, }
                          \DataTypeTok{RF    =}\NormalTok{ model_rf,}
                          \DataTypeTok{KNN   =}\NormalTok{ model_knn))}
\end{Highlighting}
\end{Shaded}

Now we can easily look at how well the different models compare:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# summarize the distributions}
\KeywordTok{summary}\NormalTok{(results)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## Call:
## summary.resamples(object = results)
## 
## Models: GLM, RPART, RF, KNN 
## Number of resamples: 5 
## 
## ROC 
##            Min.   1st Qu.    Median      Mean   3rd Qu.      Max. NA's
## GLM   0.7903774 0.8116981 0.8251852 0.8297484 0.8479630 0.8735185    0
## RPART 0.7018868 0.7136111 0.7229245 0.7455549 0.7684259 0.8209259    0
## RF    0.8068868 0.8082075 0.8111111 0.8295744 0.8565741 0.8650926    0
## KNN   0.7108491 0.7571698 0.7794444 0.7858260 0.8311111 0.8505556    0
## 
## Sens 
##       Min. 1st Qu. Median  Mean 3rd Qu. Max. NA's
## GLM   0.84    0.86   0.89 0.888    0.92 0.93    0
## RPART 0.74    0.76   0.79 0.818    0.88 0.92    0
## RF    0.84    0.84   0.84 0.852    0.87 0.87    0
## KNN   0.79    0.80   0.86 0.844    0.87 0.90    0
## 
## Spec 
##            Min.   1st Qu.    Median      Mean   3rd Qu.      Max. NA's
## GLM   0.5283019 0.5471698 0.5925926 0.5780573 0.6111111 0.6111111    0
## RPART 0.4716981 0.5740741 0.5849057 0.5928022 0.5925926 0.7407407    0
## RF    0.5555556 0.5660377 0.5849057 0.6005590 0.6481481 0.6481481    0
## KNN   0.4629630 0.5283019 0.5471698 0.5410203 0.5555556 0.6111111    0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# boxplots of results}
\KeywordTok{bwplot}\NormalTok{(results)}
\end{Highlighting}
\end{Shaded}

\includegraphics{SEMINAR_SERIES_files/figure-latex/summcomp-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# dot plots of results}
\KeywordTok{dotplot}\NormalTok{(results)}
\end{Highlighting}
\end{Shaded}

\includegraphics{SEMINAR_SERIES_files/figure-latex/summcomp-2.pdf}

\hypertarget{using-exeternal-ml-frameworks}{%
\chapter{Using Exeternal ML Frameworks}\label{using-exeternal-ml-frameworks}}

There are a number of companies that provide easy access to Machine Learning services including Google, Amazon, Data Robot, and H2o. In particular, the company H20.ai provides frameworks for accessible Machine Learning by experts and non-experts. They promote the idea of ``citizen data science'' which seeks to lower barriers to participation in the world of AI. While they have a commercial product, they also provide an open source tool:

\begin{quote}
H2O is a fully open source, distributed in-memory machine learning platform with linear
scalability. H2O supports the most widely used statistical \& machine learning algorithms
including gradient boosted machines, generalized linear models, deep learning and more.
\end{quote}

Moreover, H2O provides access to an ``Auto ML'' service that selects methods appropriate to a given data set. This is useful to help jump start ideas.

\begin{quote}
H2O also has an industry leading AutoML functionality that automatically runs through
all the algorithms and their hyperparameters to produce a leaderboard of the best models.
The H2O platform is used by over 18,000 organizations globally and is extremely popular
in both the R \& Python communities.
\end{quote}

Better yet, there is an R package called, somewhat unimaginatively, ``h2o'' ``which provides:

\begin{quote}
R interface for `H2O', the scalable open source machine learning platform that offers
parallelized implementations of many supervised and unsupervised machine learning algorithms
such as Generalized Linear Models, Gradient Boosting Machines (including XGBoost), Random
Forests, Deep Neural Networks (Deep Learning), Stacked Ensembles, Naive Bayes, Cox
Proportional Hazards, K-Means, PCA, Word2Vec, as well as a fully automatic machine learning
algorithm (AutoML).
\end{quote}

\hypertarget{h2o-in-action}{%
\section{H2O In Action}\label{h2o-in-action}}

The package must first be installed which can done using the install.packages function (or the menu in R Studio). Loading the library is done just as you would any other library.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(h2o)}
\end{Highlighting}
\end{Shaded}

The goal of using this library is not to replace the methods available to you in R but, just like the caret package, seeks to provide a uniform interface for a variety of underlying methods. This includes common methods including an ``Auto ML'' service that picks methods for you. Let's apply h2o to our work. The underlying h2o architecture uses a ``running instance'' concept that can be initialized and accessed from R. You initialize it once per interactive session.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{h2o.init}\NormalTok{()}

\NormalTok{H2O is not running yet, starting it now...}

\NormalTok{Note}\OperatorTok{:}\StringTok{  }\NormalTok{In case of errors look at the following log files}\OperatorTok{:}
\StringTok{    }\ErrorTok{/}\NormalTok{var}\OperatorTok{/}\NormalTok{folders}\OperatorTok{/}\NormalTok{wh}\OperatorTok{/}\NormalTok{z0v5hqgx3dzdfgz47lnbr_3w0000gn}\OperatorTok{/}\NormalTok{T}\OperatorTok{/}\ErrorTok{/}\NormalTok{RtmpRehHby}\OperatorTok{/}\NormalTok{h2o_esteban_started_from_r.out}
    \OperatorTok{/}\NormalTok{var}\OperatorTok{/}\NormalTok{folders}\OperatorTok{/}\NormalTok{wh}\OperatorTok{/}\NormalTok{z0v5hqgx3dzdfgz47lnbr_3w0000gn}\OperatorTok{/}\NormalTok{T}\OperatorTok{/}\ErrorTok{/}\NormalTok{RtmpRehHby}\OperatorTok{/}\NormalTok{h2o_esteban_started_from_r.err}

\NormalTok{java version }\StringTok{"1.8.0_131"}
\KeywordTok{Java}\NormalTok{(TM) SE Runtime }\KeywordTok{Environment}\NormalTok{ (build }\DecValTok{1}\NormalTok{.}\FloatTok{8.0}\NormalTok{_}\DecValTok{131}\OperatorTok{-}\NormalTok{b11)}
\NormalTok{Java }\KeywordTok{HotSpot}\NormalTok{(TM) }\DecValTok{64}\OperatorTok{-}\NormalTok{Bit Server }\KeywordTok{VM}\NormalTok{ (build }\FloatTok{25.131}\OperatorTok{-}\NormalTok{b11, mixed mode)}

\NormalTok{Starting H2O JVM and connecting}\OperatorTok{:}\StringTok{ }\NormalTok{.. Connection successful}\OperatorTok{!}

\NormalTok{R is connected to the H2O cluster}\OperatorTok{:}\StringTok{ }
\StringTok{    }\NormalTok{H2O cluster uptime}\OperatorTok{:}\StringTok{         }\DecValTok{2}\NormalTok{ seconds }\DecValTok{577}\NormalTok{ milliseconds }
\NormalTok{    H2O cluster timezone}\OperatorTok{:}\StringTok{       }\NormalTok{America}\OperatorTok{/}\NormalTok{New_York }
\NormalTok{    H2O data parsing timezone}\OperatorTok{:}\StringTok{  }\NormalTok{UTC }
\NormalTok{    H2O cluster version}\OperatorTok{:}\StringTok{        }\DecValTok{3}\NormalTok{.}\DecValTok{26}\NormalTok{.}\FloatTok{0.2} 
\NormalTok{    H2O cluster version age}\OperatorTok{:}\StringTok{    }\DecValTok{5}\NormalTok{ months and }\DecValTok{5}\NormalTok{ days }\OperatorTok{!!!}\StringTok{ }
\StringTok{    }\NormalTok{H2O cluster name}\OperatorTok{:}\StringTok{           }\NormalTok{H2O_started_from_R_esteban_pgj795 }
\NormalTok{    H2O cluster total nodes}\OperatorTok{:}\StringTok{    }\DecValTok{1} 
\NormalTok{    H2O cluster total memory}\OperatorTok{:}\StringTok{   }\FloatTok{1.78}\NormalTok{ GB }
\NormalTok{    H2O cluster total cores}\OperatorTok{:}\StringTok{    }\DecValTok{4} 
\NormalTok{    H2O cluster allowed cores}\OperatorTok{:}\StringTok{  }\DecValTok{4} 
\NormalTok{    H2O cluster healthy}\OperatorTok{:}\StringTok{        }\OtherTok{TRUE} 
\NormalTok{    H2O Connection ip}\OperatorTok{:}\StringTok{          }\NormalTok{localhost }
\NormalTok{    H2O Connection port}\OperatorTok{:}\StringTok{        }\DecValTok{54321} 
\NormalTok{    H2O Connection proxy}\OperatorTok{:}\StringTok{       }\OtherTok{NA} 
\NormalTok{    H2O Internal Security}\OperatorTok{:}\StringTok{      }\OtherTok{FALSE} 
\NormalTok{    H2O API Extensions}\OperatorTok{:}\StringTok{         }\NormalTok{Amazon S3, XGBoost, Algos, AutoML, Core V3, Core V4 }
\NormalTok{    R Version}\OperatorTok{:}\StringTok{                  }\NormalTok{R version }\DecValTok{3}\NormalTok{.}\FloatTok{5.3}\NormalTok{ (}\DecValTok{2019-03-11}\NormalTok{) }

\NormalTok{Your H2O cluster version is too }\KeywordTok{old}\NormalTok{ (}\DecValTok{5}\NormalTok{ months and }\DecValTok{5}\NormalTok{ days)}\OperatorTok{!}
\NormalTok{Please download and install the latest version from http}\OperatorTok{:}\ErrorTok{//}\NormalTok{h2o.ai}\OperatorTok{/}\NormalTok{download}\OperatorTok{/}
\NormalTok{Show }\ControlFlowTok{in}\NormalTok{ New WindowClear OutputExpand}\OperatorTok{/}\NormalTok{Collapse Output}
  \OperatorTok{|}\ErrorTok{===========================================================|}\StringTok{ }\DecValTok{100}\NormalTok{%}
\NormalTok{Console}\OperatorTok{~}\ErrorTok{/}\NormalTok{Dropbox}\OperatorTok{/}\NormalTok{ML}\OperatorTok{/}\NormalTok{bookdown}\OperatorTok{-}\NormalTok{minimal}\OperatorTok{/}
\NormalTok{Console}
\NormalTok{Terminal}

\NormalTok{R Markdown}

\OperatorTok{~}\ErrorTok{/}\NormalTok{Dropbox}\OperatorTok{/}\NormalTok{ML}\OperatorTok{/}\NormalTok{bookdown}\OperatorTok{-}\NormalTok{minimal}\OperatorTok{/}\StringTok{  }
\end{Highlighting}
\end{Shaded}

Once the h2o environment has been initialized then work can begin. This will take the form of using R functions provided by the h2o package to read in data and prepare it for use with various methods. Let's repeat the regression on mtcars using h2o functions. Since mtcars is already available in the the R environment we can easily import it into h2o.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Import mtcars}
\NormalTok{mtcars_h2o_df <-}\StringTok{ }\KeywordTok{as.h2o}\NormalTok{(mtcars)}

\CommentTok{# Idenitfy the variable to be predicted}
\NormalTok{y <-}\StringTok{ "mpg"}

\CommentTok{# Put the predictor names into a vector}
\NormalTok{x <-}\StringTok{ }\KeywordTok{setdiff}\NormalTok{(}\KeywordTok{colnames}\NormalTok{(mtcars_h2o_df),y)}
\end{Highlighting}
\end{Shaded}

\hypertarget{create-some-models}{%
\section{Create Some Models}\label{create-some-models}}

Now let's create some training and test data sets. We could do this ourselves using conventional R commands or helper functions from the caret package. However, the h2o package provides its own set of helpers.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\NormalTok{(mtcars)}
\NormalTok{splits <-}\StringTok{ }\KeywordTok{h2o.splitFrame}\NormalTok{(mtcars_h2o_df, }\DataTypeTok{ratios=}\FloatTok{0.8}\NormalTok{,}\DataTypeTok{seed=}\DecValTok{1}\NormalTok{)}
\NormalTok{train_h2o <-}\StringTok{ }\NormalTok{splits[[}\DecValTok{1}\NormalTok{]]}
\NormalTok{test_h2o  <-}\StringTok{ }\NormalTok{splits[[}\DecValTok{2}\NormalTok{]]}

\NormalTok{train}

\NormalTok{mpg cyl disp  hp drat    wt  qsec vs am gear carb}
\DecValTok{1} \FloatTok{21.0}   \DecValTok{6}  \DecValTok{160} \DecValTok{110} \FloatTok{3.90} \FloatTok{2.620} \FloatTok{16.46}  \DecValTok{0}  \DecValTok{1}    \DecValTok{4}    \DecValTok{4}
\DecValTok{2} \FloatTok{21.0}   \DecValTok{6}  \DecValTok{160} \DecValTok{110} \FloatTok{3.90} \FloatTok{2.875} \FloatTok{17.02}  \DecValTok{0}  \DecValTok{1}    \DecValTok{4}    \DecValTok{4}
\DecValTok{3} \FloatTok{21.4}   \DecValTok{6}  \DecValTok{258} \DecValTok{110} \FloatTok{3.08} \FloatTok{3.215} \FloatTok{19.44}  \DecValTok{1}  \DecValTok{0}    \DecValTok{3}    \DecValTok{1}
\DecValTok{4} \FloatTok{18.7}   \DecValTok{8}  \DecValTok{360} \DecValTok{175} \FloatTok{3.15} \FloatTok{3.440} \FloatTok{17.02}  \DecValTok{0}  \DecValTok{0}    \DecValTok{3}    \DecValTok{2}
\DecValTok{5} \FloatTok{18.1}   \DecValTok{6}  \DecValTok{225} \DecValTok{105} \FloatTok{2.76} \FloatTok{3.460} \FloatTok{20.22}  \DecValTok{1}  \DecValTok{0}    \DecValTok{3}    \DecValTok{1}
\DecValTok{6} \FloatTok{14.3}   \DecValTok{8}  \DecValTok{360} \DecValTok{245} \FloatTok{3.21} \FloatTok{3.570} \FloatTok{15.84}  \DecValTok{0}  \DecValTok{0}    \DecValTok{3}    \DecValTok{4}

\NormalTok{[}\DecValTok{29}\NormalTok{ rows x }\DecValTok{11}\NormalTok{ columns] }
\end{Highlighting}
\end{Shaded}

Now let's create a model. We'll use the Generalized Linear Model function from h2o. It is important to note that this function is implemented from within h2o. That is, we are not in anyway using any existing R packages to do this nor are we using anything from the care package. Here we'll request a 4-Fold, Cross Validation step as part of the model assembly.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{h2o_glm_model <-}\StringTok{ }\KeywordTok{h2o.glm}\NormalTok{(}\DataTypeTok{y=}\StringTok{'mpg'}\NormalTok{,}\DataTypeTok{x=}\KeywordTok{names}\NormalTok{(mtcars)[}\OperatorTok{-}\DecValTok{1}\NormalTok{],train_h2o,}\DataTypeTok{nfolds=}\DecValTok{4}\NormalTok{)}
\KeywordTok{summary}\NormalTok{(h2o_glm_model)}

\CommentTok{#}

 \OperatorTok{|}\ErrorTok{===========================================================|}\StringTok{ }\DecValTok{100}\NormalTok{%}
\NormalTok{Model Details}\OperatorTok{:}
\ErrorTok{==============}

\NormalTok{H2ORegressionModel}\OperatorTok{:}\StringTok{ }\NormalTok{glm}
\NormalTok{Model Key}\OperatorTok{:}\StringTok{  }\NormalTok{GLM_model_R_}\DecValTok{1577927955348}\NormalTok{_}\DecValTok{1} 
\NormalTok{GLM Model}\OperatorTok{:}\StringTok{ }\NormalTok{summary}
\NormalTok{    family     link                              regularization}
\DecValTok{1}\NormalTok{ gaussian identity Elastic }\KeywordTok{Net}\NormalTok{ (}\DataTypeTok{alpha =} \FloatTok{0.5}\NormalTok{, }\DataTypeTok{lambda =} \FloatTok{1.0664}\NormalTok{ )}
\NormalTok{  number_of_predictors_total number_of_active_predictors}
\DecValTok{1}                         \DecValTok{10}                           \DecValTok{9}
\NormalTok{  number_of_iterations    training_frame}
\DecValTok{1}                    \DecValTok{1}\NormalTok{ RTMP_sid_bf87_}\DecValTok{673}

\NormalTok{H2ORegressionMetrics}\OperatorTok{:}\StringTok{ }\NormalTok{glm}
\OperatorTok{**}\StringTok{ }\NormalTok{Reported on training data. }\OperatorTok{**}

\NormalTok{MSE}\OperatorTok{:}\StringTok{  }\FloatTok{6.185253}
\NormalTok{RMSE}\OperatorTok{:}\StringTok{  }\FloatTok{2.487017}
\NormalTok{MAE}\OperatorTok{:}\StringTok{  }\FloatTok{1.940791}
\NormalTok{RMSLE}\OperatorTok{:}\StringTok{  }\FloatTok{0.1135999}
\NormalTok{Mean Residual Deviance }\OperatorTok{:}\StringTok{  }\FloatTok{6.185253}
\NormalTok{R}\OperatorTok{^}\DecValTok{2} \OperatorTok{:}\StringTok{  }\FloatTok{0.8392098}
\NormalTok{Null Deviance }\OperatorTok{:}\FloatTok{1115.568}
\NormalTok{Null D.o.F. }\OperatorTok{:}\DecValTok{28}
\NormalTok{Residual Deviance }\OperatorTok{:}\FloatTok{179.3723}
\NormalTok{Residual D.o.F. }\OperatorTok{:}\DecValTok{19}
\NormalTok{AIC }\OperatorTok{:}\FloatTok{157.1413}



\NormalTok{H2ORegressionMetrics}\OperatorTok{:}\StringTok{ }\NormalTok{glm}
\OperatorTok{**}\StringTok{ }\NormalTok{Reported on cross}\OperatorTok{-}\NormalTok{validation data. }\OperatorTok{**}
\ErrorTok{**}\StringTok{ }\DecValTok{4}\OperatorTok{-}\NormalTok{fold cross}\OperatorTok{-}\NormalTok{validation on training }\KeywordTok{data}\NormalTok{ (Metrics computed }\ControlFlowTok{for}\NormalTok{ combined holdout predictions) }\OperatorTok{**}

\NormalTok{MSE}\OperatorTok{:}\StringTok{  }\FloatTok{9.520966}
\NormalTok{RMSE}\OperatorTok{:}\StringTok{  }\FloatTok{3.085606}
\NormalTok{MAE}\OperatorTok{:}\StringTok{  }\FloatTok{2.478209}
\NormalTok{RMSLE}\OperatorTok{:}\StringTok{  }\FloatTok{0.1462186}
\NormalTok{Mean Residual Deviance }\OperatorTok{:}\StringTok{  }\FloatTok{9.520966}
\NormalTok{R}\OperatorTok{^}\DecValTok{2} \OperatorTok{:}\StringTok{  }\FloatTok{0.7524955}
\NormalTok{Null Deviance }\OperatorTok{:}\FloatTok{1194.241}
\NormalTok{Null D.o.F. }\OperatorTok{:}\DecValTok{28}
\NormalTok{Residual Deviance }\OperatorTok{:}\FloatTok{276.108}
\NormalTok{Residual D.o.F. }\OperatorTok{:}\DecValTok{19}
\NormalTok{AIC }\OperatorTok{:}\FloatTok{169.6498}


\NormalTok{Cross}\OperatorTok{-}\NormalTok{Validation Metrics Summary}\OperatorTok{:}\StringTok{ }
\StringTok{                            }\NormalTok{mean          sd cv_}\DecValTok{1}\NormalTok{_valid cv_}\DecValTok{2}\NormalTok{_valid}
\NormalTok{mae                    }\FloatTok{2.4294133}   \FloatTok{0.4533141}  \FloatTok{3.3255308}  \FloatTok{2.6851656}
\NormalTok{mean_residual_deviance  }\FloatTok{9.431254}   \FloatTok{2.5729601}  \FloatTok{11.924386}  \FloatTok{13.098149}
\NormalTok{mse                     }\FloatTok{9.431254}   \FloatTok{2.5729601}  \FloatTok{11.924386}  \FloatTok{13.098149}
\NormalTok{null_deviance          }\FloatTok{298.56015}    \FloatTok{73.43793}   \FloatTok{429.7452}  \FloatTok{322.68143}
\NormalTok{r2                     }\FloatTok{0.7409388} \FloatTok{0.041704282}  \FloatTok{0.6850852} \FloatTok{0.70873845}
\NormalTok{residual_deviance         }\FloatTok{69.027}   \FloatTok{21.894964}  \FloatTok{107.31948}  \FloatTok{65.490746}
\NormalTok{rmse                   }\FloatTok{2.9984744}  \FloatTok{0.46925735}  \FloatTok{3.4531705}  \FloatTok{3.6191366}
\NormalTok{rmsle                  }\FloatTok{0.1363086} \FloatTok{0.026307607} \FloatTok{0.19733523} \FloatTok{0.13199924}
\NormalTok{                       cv_}\DecValTok{3}\NormalTok{_valid cv_}\DecValTok{4}\NormalTok{_valid}
\NormalTok{mae                     }\FloatTok{1.6167169}  \FloatTok{2.0902402}
\NormalTok{mean_residual_deviance  }\FloatTok{3.6748443}   \FloatTok{9.027636}
\NormalTok{mse                     }\FloatTok{3.6748443}   \FloatTok{9.027636}
\NormalTok{null_deviance           }\FloatTok{139.37894}  \FloatTok{302.43506}
\NormalTok{r2                     }\FloatTok{0.83919096} \FloatTok{0.73074067}
\NormalTok{residual_deviance       }\FloatTok{22.049067}   \FloatTok{81.24872}
\NormalTok{rmse                    }\FloatTok{1.9169884}  \FloatTok{3.0046024}
\NormalTok{rmsle                   }\FloatTok{0.0983199} \FloatTok{0.11758001}

\NormalTok{Scoring History}\OperatorTok{:}\StringTok{ }
\StringTok{            }\NormalTok{timestamp   duration iterations negative_log_likelihood}
\DecValTok{1} \DecValTok{2020-01-01} \DecValTok{20}\OperatorTok{:}\DecValTok{21}\OperatorTok{:}\DecValTok{13}  \FloatTok{0.000}\NormalTok{ sec          }\DecValTok{0}              \FloatTok{1115.56759}
\NormalTok{  objective}
\DecValTok{1}  \FloatTok{38.46785}

\NormalTok{Variable Importances}\OperatorTok{:}\StringTok{ }\NormalTok{(Extract with }\StringTok{`}\DataTypeTok{h2o.varimp}\StringTok{`}\NormalTok{) }
\OperatorTok{==}\ErrorTok{===============================================}

\StringTok{   }\NormalTok{variable relative_importance scaled_importance  percentage}
\DecValTok{1}\NormalTok{        wt          }\FloatTok{1.19294625}        \FloatTok{1.00000000} \FloatTok{0.208632891}
\DecValTok{2}\NormalTok{       cyl          }\FloatTok{0.92951526}        \FloatTok{0.77917615} \FloatTok{0.162561772}
\DecValTok{3}\NormalTok{      disp          }\FloatTok{0.78424629}        \FloatTok{0.65740287} \FloatTok{0.137155861}
\DecValTok{4}\NormalTok{        hp          }\FloatTok{0.69294345}        \FloatTok{0.58086729} \FloatTok{0.121188021}
\DecValTok{5}\NormalTok{      carb          }\FloatTok{0.62287613}        \FloatTok{0.52213261} \FloatTok{0.108934035}
\DecValTok{6}\NormalTok{        am          }\FloatTok{0.55736672}        \FloatTok{0.46721864} \FloatTok{0.097477175}
\DecValTok{7}\NormalTok{        vs          }\FloatTok{0.46246830}        \FloatTok{0.38766902} \FloatTok{0.080880507}
\DecValTok{8}\NormalTok{      drat          }\FloatTok{0.45447201}        \FloatTok{0.38096604} \FloatTok{0.079482047}
\DecValTok{9}\NormalTok{      gear          }\FloatTok{0.02108593}        \FloatTok{0.01767551} \FloatTok{0.003687692}
\DecValTok{10}\NormalTok{     qsec          }\FloatTok{0.00000000}        \FloatTok{0.00000000} \FloatTok{0.000000000}
\end{Highlighting}
\end{Shaded}

Now we can do a prediction on the object against the test set.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(h2o_glm_preds <-}\StringTok{ }\KeywordTok{h2o.predict}\NormalTok{(h2o_glm_model,test_h2o))}

\CommentTok{#}
\KeywordTok{h2o.performance}\NormalTok{(h2o_glm_model,test_h2o)}

 \OperatorTok{|}\ErrorTok{===========================================================|}\StringTok{ }\DecValTok{100}\NormalTok{%}
\NormalTok{   predict}
\DecValTok{1} \FloatTok{25.93186}
\DecValTok{2} \FloatTok{20.67344}
\DecValTok{3} \FloatTok{24.38237}

\NormalTok{[}\DecValTok{3}\NormalTok{ rows x }\DecValTok{1}\NormalTok{ column] }
\NormalTok{H2ORegressionMetrics}\OperatorTok{:}\StringTok{ }\NormalTok{glm}

\NormalTok{MSE}\OperatorTok{:}\StringTok{  }\FloatTok{6.762548}
\NormalTok{RMSE}\OperatorTok{:}\StringTok{  }\FloatTok{2.60049}
\NormalTok{MAE}\OperatorTok{:}\StringTok{  }\FloatTok{2.495891}
\NormalTok{RMSLE}\OperatorTok{:}\StringTok{  }\FloatTok{0.1076563}
\NormalTok{Mean Residual Deviance }\OperatorTok{:}\StringTok{  }\FloatTok{6.762548}
\NormalTok{R}\OperatorTok{^}\DecValTok{2} \OperatorTok{:}\StringTok{  }\FloatTok{-2.052306}
\NormalTok{Null Deviance }\OperatorTok{:}\FloatTok{10.87611}
\NormalTok{Null D.o.F. }\OperatorTok{:}\DecValTok{2}
\NormalTok{Residual Deviance }\OperatorTok{:}\FloatTok{20.28765}
\NormalTok{Residual D.o.F. }\OperatorTok{:-}\DecValTok{7}
\NormalTok{AIC }\OperatorTok{:}\FloatTok{36.24783}
\end{Highlighting}
\end{Shaded}

Now look at the performance diagnostics:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{h2o.performance}\NormalTok{(h2o_glm_model,test_h2o)}

\NormalTok{H2ORegressionMetrics}\OperatorTok{:}\StringTok{ }\NormalTok{glm}

\NormalTok{MSE}\OperatorTok{:}\StringTok{  }\FloatTok{6.762548}
\NormalTok{RMSE}\OperatorTok{:}\StringTok{  }\FloatTok{2.60049}
\NormalTok{MAE}\OperatorTok{:}\StringTok{  }\FloatTok{2.495891}
\NormalTok{RMSLE}\OperatorTok{:}\StringTok{  }\FloatTok{0.1076563}
\NormalTok{Mean Residual Deviance }\OperatorTok{:}\StringTok{  }\FloatTok{6.762548}
\NormalTok{R}\OperatorTok{^}\DecValTok{2} \OperatorTok{:}\StringTok{  }\FloatTok{-2.052306}
\NormalTok{Null Deviance }\OperatorTok{:}\FloatTok{10.87611}
\NormalTok{Null D.o.F. }\OperatorTok{:}\DecValTok{2}
\NormalTok{Residual Deviance }\OperatorTok{:}\FloatTok{20.28765}
\NormalTok{Residual D.o.F. }\OperatorTok{:-}\DecValTok{7}
\NormalTok{AIC }\OperatorTok{:}\FloatTok{36.24783}
\end{Highlighting}
\end{Shaded}

\hypertarget{saving-a-model}{%
\section{Saving A Model}\label{saving-a-model}}

You can save the contents of any h2o generated model by using the h2o.saveModel() function. You could extract pieces of information from the S4 object but saving the model is easy to do - as is reading it back in.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{model_path <-}\StringTok{ }\KeywordTok{h2o.saveModel}\NormalTok{(h2o_glm_model,}\DataTypeTok{path=}\KeywordTok{getwd}\NormalTok{(),}\DataTypeTok{force=}\OtherTok{TRUE}\NormalTok{)}

\CommentTok{# If you need to load a previously saved model}

\NormalTok{saved_model <-}\StringTok{ }\KeywordTok{h2o.loadModel}\NormalTok{(model_path)}
\end{Highlighting}
\end{Shaded}

\hypertarget{using-the-auto-ml-feature}{%
\section{Using the Auto ML Feature}\label{using-the-auto-ml-feature}}

Are you curious as to what model might be the ``best'' for your data ? This is a very fertile field of research that keeps growing and some feel will one be the dominant technology in ML - where a model picks a model. Sounds odd but that is where it is heading. Check the current h2o Auto ML documentation for more details. For now, most of the Auto ML services use a set of heuristics to examine data and then find the most appropriate method to build a model. The currently supported method implementations in the opensource version include:

\begin{verbatim}
- three pre-specified XGBoost GBM (Gradient Boosting Machine) models
- a fixed grid of GLMs, a default Random Forest (DRF)
- five pre-specified H2O GBMs
- a near-default Deep Neural Net
- an Extremely Randomized Forest (XRT)
- a random grid of XGBoost GBMs
- a random grid of H2O GBMs
- a random grid of Deep Neural Nets.
\end{verbatim}

\hypertarget{launching-a-job}{%
\section{Launching A Job}\label{launching-a-job}}

Of course, it all begins with the idea of specifying a performance metric such as RMSE or the area under a ROC curve. The idea here is that we specify some input, apply transformations, create a test/train pair, and then call the h2o auto function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x =}\StringTok{ }\KeywordTok{names}\NormalTok{(mtcars)[}\OperatorTok{-}\DecValTok{1}\NormalTok{]}
\KeywordTok{h2o.automl}\NormalTok{(}\DataTypeTok{y =} \StringTok{'mpg'}\NormalTok{, }\DataTypeTok{x =}\NormalTok{ x,}
                      \DataTypeTok{training_frame =}\NormalTok{ train_h2o,}
                      \DataTypeTok{leaderboard_frame =}\NormalTok{ test_h2o,}
                      \DataTypeTok{max_runtime_secs =} \DecValTok{60}\NormalTok{,}
                      \DataTypeTok{seed =} \DecValTok{1}\NormalTok{,}
                      \DataTypeTok{sort_metric =} \StringTok{"RMSE"}\NormalTok{,}
                      \DataTypeTok{project_name =} \StringTok{"mtcars"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Let's check out the object that is returned. It is an S4 object in R which means that it has ``slots'' which can be accessed via the ``@'' operator.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{slotNames}\NormalTok{(h2o_auto_mtcars)}
\NormalTok{h2o_auto_mtcars}\OperatorTok{@}\NormalTok{leaderboard}

\NormalTok{[}\DecValTok{1}\NormalTok{] }\StringTok{"project_name"}  \StringTok{"leader"}        \StringTok{"leaderboard"}   \StringTok{"event_log"}    
\NormalTok{[}\DecValTok{5}\NormalTok{] }\StringTok{"training_info"}
\NormalTok{                                        model_id}
\DecValTok{1}\NormalTok{     GBM_grid_}\DecValTok{1}\NormalTok{_AutoML_}\DecValTok{20200101}\NormalTok{_}\DecValTok{202413}\NormalTok{_model_}\DecValTok{53}
\DecValTok{2}\NormalTok{          DeepLearning_}\DecValTok{1}\NormalTok{_AutoML_}\DecValTok{20200101}\NormalTok{_}\DecValTok{202413}
\DecValTok{3}\NormalTok{ XGBoost_grid_}\DecValTok{1}\NormalTok{_AutoML_}\DecValTok{20200101}\NormalTok{_}\DecValTok{202413}\NormalTok{_model_}\DecValTok{14}
\DecValTok{4}\NormalTok{  XGBoost_grid_}\DecValTok{1}\NormalTok{_AutoML_}\DecValTok{20200101}\NormalTok{_}\DecValTok{202413}\NormalTok{_model_}\DecValTok{5}
\DecValTok{5}\NormalTok{     GBM_grid_}\DecValTok{1}\NormalTok{_AutoML_}\DecValTok{20200101}\NormalTok{_}\DecValTok{202413}\NormalTok{_model_}\DecValTok{52}
\DecValTok{6}\NormalTok{     GBM_grid_}\DecValTok{1}\NormalTok{_AutoML_}\DecValTok{20200101}\NormalTok{_}\DecValTok{202413}\NormalTok{_model_}\DecValTok{16}
\NormalTok{  mean_residual_deviance      rmse       mse       mae      rmsle}
\DecValTok{1}              \FloatTok{0.2147231} \FloatTok{0.4633822} \FloatTok{0.2147231} \FloatTok{0.4138704} \FloatTok{0.02128094}
\DecValTok{2}              \FloatTok{0.3734735} \FloatTok{0.6111248} \FloatTok{0.3734735} \FloatTok{0.5076945} \FloatTok{0.02559229}
\DecValTok{3}              \FloatTok{0.4586288} \FloatTok{0.6772213} \FloatTok{0.4586288} \FloatTok{0.6318582} \FloatTok{0.03060372}
\DecValTok{4}              \FloatTok{0.4787276} \FloatTok{0.6919014} \FloatTok{0.4787276} \FloatTok{0.5760670} \FloatTok{0.03091116}
\DecValTok{5}              \FloatTok{0.7571985} \FloatTok{0.8701716} \FloatTok{0.7571985} \FloatTok{0.7831136} \FloatTok{0.03729489}
\DecValTok{6}              \FloatTok{0.7772694} \FloatTok{0.8816289} \FloatTok{0.7772694} \FloatTok{0.8020415} \FloatTok{0.03896093}

\NormalTok{[}\DecValTok{89}\NormalTok{ rows x }\DecValTok{6}\NormalTok{ columns] }
\end{Highlighting}
\end{Shaded}

Stop the H2O instance

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{h2o.shutdown}\NormalTok{(}\DataTypeTok{prompt=}\OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

  \bibliography{book.bib,packages.bib}

\end{document}
